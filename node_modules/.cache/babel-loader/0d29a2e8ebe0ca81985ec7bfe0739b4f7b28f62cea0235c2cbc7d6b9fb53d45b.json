{"ast":null,"code":"import { jsx as e } from \"react/jsx-runtime\";\nimport { forwardRef as t, useRef as o, useMemo as i, useCallback as n } from \"react\";\nimport r from \"classnames\";\nimport { comboboxItemRenderer as s } from \"../../ComboboxHelpers/ComboboxHelpers.js\";\nimport a from \"../../../VirtualizedList/VirtualizedList.js\";\nimport { COMBOBOX_CATEGORY_ITEM as l, COMBOBOX_OPTION_ITEM as m } from \"../ComboboxConstants.js\";\nimport c from \"./ComboboxItems.module.scss.js\";\nvar p = t(function (t, p) {\n  var d = t.className,\n    u = t.optionClassName,\n    f = t.categories,\n    g = t.options,\n    C = t.optionRenderer,\n    v = t.activeItemIndex,\n    I = t.visualFocusItemIndex,\n    b = t.onOptionClick,\n    y = t.onOptionEnter,\n    h = t.onOptionLeave,\n    x = t.optionLineHeight,\n    O = t.shouldScrollToSelectedItem,\n    j = t.renderOnlyVisibleOptions,\n    L = t.onActiveCategoryChanged,\n    N = t.maxOptionsWithoutScroll,\n    R = t.itemsMap,\n    k = t.stickyCategories,\n    S = o(),\n    H = i(function () {\n      if (N) return {\n        height: x * Math.min(g.length + Object.keys(null != f ? f : {}).length, N + .5)\n      };\n    }, [N, x, g, f]),\n    V = n(function (e, t, o) {\n      return s({\n        stickyCategories: k,\n        item: e,\n        style: o,\n        optionEvents: {\n          onOptionClick: b,\n          onOptionEnter: y,\n          onOptionLeave: h\n        },\n        optionRenderData: {\n          className: u,\n          optionLineHeight: x,\n          optionRenderer: C,\n          visualFocusItemIndex: I,\n          scrollRef: j ? null : p,\n          activeItemIndex: v,\n          shouldScrollToSelectedItem: O\n        },\n        isVirtualized: j\n      });\n    }, [b, y, h, u, x, C, I, j, p, v, O]),\n    z = n(function (e) {\n      var t = e.firstItemId;\n      window.requestAnimationFrame(function () {\n        var e = R.get(t);\n        if (e && (e.type === l || e.type === m)) {\n          var o = e.type === m && e.categoryId ? e.categoryId : e.id;\n          if (o !== S.current) {\n            S.current = o;\n            var i = R.get(S.current);\n            L(i);\n          }\n        }\n      });\n    }, [R, L]);\n  return j ? e(a, {\n    ref: p,\n    className: r(c.optionsContainer, d),\n    items: g,\n    itemRenderer: V,\n    role: \"treegrid\",\n    scrollableClassName: c.scrollableContainer,\n    onItemsRendered: z,\n    style: H\n  }) : e(\"div\", Object.assign({\n    className: r(c.scrollableContainer, c.optionsContainer, d),\n    role: \"treegrid\",\n    style: H,\n    ref: p\n  }, {\n    children: g.map(function (e, t) {\n      return V(e, t, void 0);\n    })\n  }));\n});\nexport { p as ComboboxItems };","map":{"version":3,"names":["p","t","d","className","u","optionClassName","f","categories","g","options","C","optionRenderer","v","activeItemIndex","I","visualFocusItemIndex","b","onOptionClick","y","onOptionEnter","h","onOptionLeave","x","optionLineHeight","O","shouldScrollToSelectedItem","j","renderOnlyVisibleOptions","L","onActiveCategoryChanged","N","maxOptionsWithoutScroll","R","itemsMap","k","stickyCategories","S","o","H","i","height","Math","min","length","Object","keys","V","n","e","s","item","style","optionEvents","optionRenderData","scrollRef","isVirtualized","z","firstItemId","window","requestAnimationFrame","get","type","l","m","categoryId","id","current","a","ref","r","c","optionsContainer","items","itemRenderer","role","scrollableClassName","scrollableContainer","onItemsRendered","assign","children","map","ComboboxItems"],"sources":["/Users/huynhmannguyen/Documents/GitHub/Huy_app/node_modules/monday-ui-react-core/src/components/Combobox/components/ComboboxItems/ComboboxItems.tsx"],"sourcesContent":["import React, { CSSProperties, forwardRef, RefObject, useCallback, useMemo, useRef } from \"react\";\nimport cx from \"classnames\";\nimport { comboboxItemRenderer } from \"../../ComboboxHelpers/ComboboxHelpers\";\nimport VirtualizedList from \"../../../../components/VirtualizedList/VirtualizedList\";\nimport {\n  COMBOBOX_CATEGORY_ITEM,\n  COMBOBOX_OPTION_ITEM,\n  IComboboxCategoryMap,\n  IComboboxItem,\n  IComboboxOption,\n  IComboboxOptionEvents\n} from \"../ComboboxConstants\";\nimport styles from \"./ComboboxItems.module.scss\";\n\ninterface ComboboxItemsProps extends IComboboxOptionEvents {\n  className?: string;\n  optionClassName?: string;\n  categories?: IComboboxCategoryMap;\n  options?: IComboboxItem[];\n  optionRenderer?: (option: IComboboxOption) => JSX.Element;\n  activeItemIndex?: number;\n  visualFocusItemIndex?: number;\n  optionLineHeight?: number;\n  shouldScrollToSelectedItem?: boolean;\n  renderOnlyVisibleOptions?: boolean;\n  onActiveCategoryChanged?: (category: IComboboxItem) => void;\n  maxOptionsWithoutScroll?: number;\n  itemsMap?: Map<string, IComboboxItem>;\n  stickyCategories?: boolean;\n}\n\nexport const ComboboxItems: React.FC<ComboboxItemsProps> = forwardRef(\n  (\n    {\n      className,\n      optionClassName,\n      categories,\n      options,\n      optionRenderer,\n      activeItemIndex,\n      visualFocusItemIndex,\n      onOptionClick,\n      onOptionEnter,\n      onOptionLeave,\n      optionLineHeight,\n      shouldScrollToSelectedItem,\n      renderOnlyVisibleOptions,\n      onActiveCategoryChanged,\n      maxOptionsWithoutScroll,\n      itemsMap,\n      stickyCategories\n    },\n    ref: RefObject<HTMLDivElement>\n  ) => {\n    const activeCategoryId = useRef<string>();\n    const style = useMemo(() => {\n      if (maxOptionsWithoutScroll) {\n        // Adding 0.5 to show next option to indicate scroll is available\n        const maxCount = Math.min(options.length + Object.keys(categories ?? {}).length, maxOptionsWithoutScroll + 0.5);\n        return { height: optionLineHeight * maxCount };\n      }\n      return undefined;\n    }, [maxOptionsWithoutScroll, optionLineHeight, options, categories]);\n\n    const createItemElementRenderer = useCallback(\n      (item: IComboboxItem, index: number, style: CSSProperties) =>\n        comboboxItemRenderer({\n          stickyCategories,\n          item,\n          style,\n          optionEvents: {\n            onOptionClick,\n            onOptionEnter,\n            onOptionLeave\n          },\n          optionRenderData: {\n            className: optionClassName,\n            optionLineHeight,\n            optionRenderer,\n            visualFocusItemIndex,\n            scrollRef: renderOnlyVisibleOptions ? null : ref,\n            activeItemIndex,\n            shouldScrollToSelectedItem\n          },\n          isVirtualized: renderOnlyVisibleOptions\n        }),\n      [\n        onOptionClick,\n        onOptionEnter,\n        onOptionLeave,\n        optionClassName,\n        optionLineHeight,\n        optionRenderer,\n        visualFocusItemIndex,\n        renderOnlyVisibleOptions,\n        ref,\n        activeItemIndex,\n        shouldScrollToSelectedItem\n      ]\n    );\n\n    const onItemsRender = useCallback(\n      ({ firstItemId }: { firstItemId?: string }) => {\n        window.requestAnimationFrame(() => {\n          const itemData = itemsMap.get(firstItemId);\n          if (itemData && (itemData.type === COMBOBOX_CATEGORY_ITEM || itemData.type === COMBOBOX_OPTION_ITEM)) {\n            const newActiveCategoryId =\n              itemData.type === COMBOBOX_OPTION_ITEM && itemData.categoryId ? itemData.categoryId : itemData.id;\n\n            if (newActiveCategoryId !== activeCategoryId.current) {\n              activeCategoryId.current = newActiveCategoryId;\n              const categoryObject = itemsMap.get(activeCategoryId.current);\n              onActiveCategoryChanged(categoryObject);\n            }\n          }\n        });\n      },\n      [itemsMap, onActiveCategoryChanged]\n    );\n\n    let itemsElements;\n\n    // If we request to render only the items which visible in a given moment (optimization for very large lists)\n    if (renderOnlyVisibleOptions) {\n      itemsElements = (\n        <VirtualizedList\n          ref={ref}\n          className={cx(styles.optionsContainer, className)}\n          items={options}\n          itemRenderer={createItemElementRenderer}\n          role=\"treegrid\"\n          scrollableClassName={styles.scrollableContainer}\n          onItemsRendered={onItemsRender}\n          style={style}\n        />\n      );\n    } else {\n      itemsElements = (\n        <div\n          className={cx(styles.scrollableContainer, styles.optionsContainer, className)}\n          role=\"treegrid\"\n          style={style}\n          ref={ref}\n        >\n          {options.map((itemData, index) => createItemElementRenderer(itemData, index, undefined))}\n        </div>\n      );\n    }\n\n    return itemsElements;\n  }\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}