{"ast":null,"code":"import { jsx as e, jsxs as o } from \"react/jsx-runtime\";\nimport { useCallback as t } from \"react\";\nimport i from \"../../hooks/useKeyEvent/index.js\";\nimport r from \"../Flex/Flex.js\";\nimport n from \"../Avatar/Avatar.js\";\nimport c from \"../Clickable/ClickableWrapper.js\";\nimport s from \"./AvatarGroupCounterTooltipContent.module.scss.js\";\nimport a from \"../../hooks/useEventListener/index.js\";\nimport l from \"../../hooks/useListenFocusTriggers/index.js\";\nimport { AVATAR_GROUP_COUNTER_TOOLTIP_SHOW_DELAY as u, AVATAR_GROUP_COUNTER_AVATAR_SIZE as f } from \"./AvatarGroupConstants.js\";\nimport { keyCodes as d } from \"../../constants/keyCodes.js\";\nvar m = [d.TAB],\n  b = [d.ESCAPE];\nfunction p(e) {\n  var o = e.counterContainerRef,\n    r = void 0 === o ? void 0 : o,\n    n = e.tooltipContentContainerRef,\n    c = e.focusPrevPlaceholderRef,\n    s = e.focusNextPlaceholderRef,\n    f = e.isKeyboardTooltipVisible,\n    d = e.setIsKeyboardTooltipVisible,\n    p = t(function () {\n      f || setTimeout(function () {\n        return d(!0);\n      }, u);\n    }, [f, d]),\n    v = t(function () {\n      f && d(!1);\n    }, [f, d]);\n  l({\n    ref: r,\n    onFocusByKeyboard: p\n  }), a({\n    eventName: \"blur\",\n    ref: n,\n    callback: v\n  }), i({\n    keys: m,\n    ref: r,\n    withoutAnyModifier: !0,\n    preventDefault: !0,\n    callback: t(function () {\n      f && (null == n ? void 0 : n.current) && n.current.focus();\n    }, [f, n])\n  }), i({\n    keys: m,\n    modifier: i.modifiers.SHIFT,\n    ref: r,\n    callback: v\n  }), i({\n    keys: m,\n    ref: n,\n    withoutAnyModifier: !0,\n    callback: t(function () {\n      (null == s ? void 0 : s.current) && s.current.focus(), f && d(!1);\n    }, [s, f, d])\n  }), i({\n    keys: m,\n    ref: n,\n    modifier: i.modifiers.SHIFT,\n    callback: t(function () {\n      (null == c ? void 0 : c.current) && c.current.focus(), f && d(!1);\n    }, [c, f, d])\n  }), i({\n    keys: b,\n    ref: n,\n    callback: t(function () {\n      (null == r ? void 0 : r.current) && r.current.focus(), f && d(!1);\n    }, [r, f, d])\n  }), i({\n    keys: b,\n    ref: r,\n    callback: v\n  }), a({\n    eventName: \"focus\",\n    ref: s,\n    callback: v\n  });\n}\nvar v = function (t, i, a, l, u) {\n  var d = t.value,\n    m = Object.assign(Object.assign({}, a), {\n      width: u ? void 0 : \"100%\"\n    }),\n    b = \"tooltip-item-\".concat(i, \"-label\");\n  return e(c, Object.assign({\n    isClickable: !!(null == d ? void 0 : d.onClick),\n    clickableProps: {\n      onClick: function (e) {\n        return d.onClick(e, d.id);\n      },\n      tabIndex: \"-1\"\n    }\n  }, {\n    children: e(\"div\", Object.assign({\n      style: m\n    }, {\n      children: o(r, Object.assign({\n        direction: r.directions.ROW,\n        gap: r.gaps.XS,\n        ariaLabelledby: b\n      }, {\n        children: [e(n, Object.assign({}, d, {\n          tooltipProps: void 0,\n          ariaLabel: \"\",\n          customSize: f,\n          type: l || (null == d ? void 0 : d.type),\n          tabIndex: -1\n        })), !u && e(\"div\", Object.assign({\n          id: b,\n          className: s.tooltipAvatarItemTitle\n        }, {\n          children: d.tooltipContent\n        }))]\n      }))\n    }))\n  }), i);\n};\nexport { v as avatarRenderer, p as useTooltipContentTabNavigation };","map":{"version":3,"names":["m","d","TAB","b","ESCAPE","p","e","o","counterContainerRef","r","n","tooltipContentContainerRef","c","focusPrevPlaceholderRef","s","focusNextPlaceholderRef","f","isKeyboardTooltipVisible","setIsKeyboardTooltipVisible","t","setTimeout","u","v","l","ref","onFocusByKeyboard","a","eventName","callback","i","keys","withoutAnyModifier","preventDefault","current","focus","modifier","modifiers","SHIFT","avatarRenderer","value","Object","assign","width","concat","isClickable","onClick","clickableProps","id","tabIndex","children","style","direction","directions","ROW","gap","gaps","XS","ariaLabelledby","tooltipProps","ariaLabel","customSize","type","className","tooltipAvatarItemTitle","tooltipContent","useTooltipContentTabNavigation"],"sources":["/Users/huynhmannguyen/Documents/GitHub/Huy_app/node_modules/monday-ui-react-core/src/components/AvatarGroup/AvatarGroupCounterTooltipHelper.tsx"],"sourcesContent":["import React, { CSSProperties, RefObject, useCallback } from \"react\";\nimport useKeyEvent from \"../../hooks/useKeyEvent\";\nimport Flex from \"../Flex/Flex\";\nimport Avatar, { AvatarProps } from \"../Avatar/Avatar\";\nimport ClickableWrapper from \"../Clickable/ClickableWrapper\";\nimport avatarGroupCounterTooltipContentStyles from \"./AvatarGroupCounterTooltipContent.module.scss\";\nimport useEventListener from \"../../hooks/useEventListener\";\nimport useListenFocusTriggers from \"../../hooks/useListenFocusTriggers\";\nimport { AvatarType } from \"../Avatar/AvatarConstants\";\nimport { ElementContent } from \"src/types/ElementContent\";\nimport { AVATAR_GROUP_COUNTER_AVATAR_SIZE, AVATAR_GROUP_COUNTER_TOOLTIP_SHOW_DELAY } from \"./AvatarGroupConstants\";\nimport { keyCodes } from \"../../constants\";\n\nconst TAB = [keyCodes.TAB];\nconst ESC = [keyCodes.ESCAPE];\n\nexport function useTooltipContentTabNavigation({\n  counterContainerRef = undefined,\n  tooltipContentContainerRef,\n  focusPrevPlaceholderRef,\n  focusNextPlaceholderRef,\n  isKeyboardTooltipVisible,\n  setIsKeyboardTooltipVisible\n}: {\n  counterContainerRef: RefObject<HTMLDivElement>;\n  tooltipContentContainerRef: RefObject<HTMLElement>;\n  focusPrevPlaceholderRef: RefObject<HTMLDivElement>;\n  focusNextPlaceholderRef: RefObject<HTMLDivElement>;\n  isKeyboardTooltipVisible: boolean;\n  setIsKeyboardTooltipVisible: (value: boolean) => void;\n}) {\n  const showKeyboardTooltip = useCallback(() => {\n    if (!isKeyboardTooltipVisible) {\n      // temp hack for display tooltip with delay after timeout because refactoring the tooltip with open mechanism is out of scope\n      setTimeout(() => setIsKeyboardTooltipVisible(true), AVATAR_GROUP_COUNTER_TOOLTIP_SHOW_DELAY);\n    }\n  }, [isKeyboardTooltipVisible, setIsKeyboardTooltipVisible]);\n\n  const hideKeyboardTooltip = useCallback(() => {\n    if (isKeyboardTooltipVisible) setIsKeyboardTooltipVisible(false);\n  }, [isKeyboardTooltipVisible, setIsKeyboardTooltipVisible]);\n\n  // Open tooltip manually when keyboard focusing on counter\n  useListenFocusTriggers({\n    ref: counterContainerRef,\n    onFocusByKeyboard: showKeyboardTooltip\n  });\n\n  useEventListener({\n    eventName: \"blur\",\n    ref: tooltipContentContainerRef,\n    callback: hideKeyboardTooltip\n  });\n\n  //Move focus to content by keyboard\n  useKeyEvent({\n    keys: TAB,\n    ref: counterContainerRef,\n    withoutAnyModifier: true,\n    preventDefault: true,\n    callback: useCallback(() => {\n      if (isKeyboardTooltipVisible) tooltipContentContainerRef?.current && tooltipContentContainerRef.current.focus();\n    }, [isKeyboardTooltipVisible, tooltipContentContainerRef])\n  });\n\n  // Close tooltip by keyboard\n  useKeyEvent({\n    keys: TAB,\n    modifier: useKeyEvent.modifiers.SHIFT,\n    ref: counterContainerRef,\n    callback: hideKeyboardTooltip\n  });\n  useKeyEvent({\n    keys: TAB,\n    ref: tooltipContentContainerRef,\n    withoutAnyModifier: true,\n    callback: useCallback(() => {\n      // We are not preventing default behaviour here and that's why after pressing tab and after moving focus to here\n      // the browser will move the focus to the next element in the focus order.\n      focusNextPlaceholderRef?.current && focusNextPlaceholderRef.current.focus();\n      if (isKeyboardTooltipVisible) setIsKeyboardTooltipVisible(false);\n    }, [focusNextPlaceholderRef, isKeyboardTooltipVisible, setIsKeyboardTooltipVisible])\n  });\n  useKeyEvent({\n    keys: TAB,\n    ref: tooltipContentContainerRef,\n    modifier: useKeyEvent.modifiers.SHIFT,\n    callback: useCallback(() => {\n      // We are not preventing default behaviour here and that's why after pressing tab and after moving focus to here\n      // the browser will move the focus to the next element in the focus order.\n      focusPrevPlaceholderRef?.current && focusPrevPlaceholderRef.current.focus();\n      if (isKeyboardTooltipVisible) setIsKeyboardTooltipVisible(false);\n    }, [focusPrevPlaceholderRef, isKeyboardTooltipVisible, setIsKeyboardTooltipVisible])\n  });\n  useKeyEvent({\n    keys: ESC,\n    ref: tooltipContentContainerRef,\n    callback: useCallback(() => {\n      counterContainerRef?.current && counterContainerRef.current.focus();\n      if (isKeyboardTooltipVisible) setIsKeyboardTooltipVisible(false);\n    }, [counterContainerRef, isKeyboardTooltipVisible, setIsKeyboardTooltipVisible])\n  });\n  useKeyEvent({\n    keys: ESC,\n    ref: counterContainerRef,\n    callback: hideKeyboardTooltip\n  });\n\n  // Close tooltip when moving focus to next element\n  useEventListener({\n    eventName: \"focus\",\n    ref: focusNextPlaceholderRef,\n    callback: hideKeyboardTooltip\n  });\n}\n\nexport const avatarRenderer = (\n  item: { value: AvatarProps & { tooltipContent: ElementContent } },\n  index: number,\n  style: CSSProperties,\n  type: AvatarType,\n  displayAsGrid: boolean\n) => {\n  const avatarProps = item.value;\n  const overrideStyle: CSSProperties = { ...style, width: displayAsGrid ? undefined : \"100%\" };\n  const labelId = `tooltip-item-${index}-label`;\n\n  return (\n    <ClickableWrapper\n      key={index}\n      isClickable={!!avatarProps?.onClick}\n      clickableProps={{ onClick: event => avatarProps.onClick(event, avatarProps.id), tabIndex: \"-1\" }}\n    >\n      <div style={overrideStyle}>\n        <Flex direction={Flex.directions.ROW} gap={Flex.gaps.XS} ariaLabelledby={labelId}>\n          <Avatar\n            {...avatarProps}\n            tooltipProps={undefined}\n            ariaLabel={\"\"}\n            customSize={AVATAR_GROUP_COUNTER_AVATAR_SIZE}\n            type={type || avatarProps?.type}\n            tabIndex={-1}\n          />\n          {!displayAsGrid && (\n            <div id={labelId} className={avatarGroupCounterTooltipContentStyles.tooltipAvatarItemTitle}>\n              {avatarProps.tooltipContent}\n            </div>\n          )}\n        </Flex>\n      </div>\n    </ClickableWrapper>\n  );\n};\n"],"mappings":";;;;;;;;;;;AAaA,IAAMA,CAAA,GAAM,CAACC,CAAA,CAASC,GAAA;EAChBC,CAAA,GAAM,CAACF,CAAA,CAASG,MAAA;AAAA,SAENC,EAA8BC,CAAA;EAc7C,IAAAC,CAAA,GAAAD,CAAA,CAbCE,mBAAA;IAAAC,CAAA,QAAsB,MAAHF,CAAA,QAAG,IAASA,CAAA;IAC/BG,CAAA,GAA0BJ,CAAA,CAA1BK,0BAAA;IACAC,CAAA,GAAuBN,CAAA,CAAvBO,uBAAA;IACAC,CAAA,GAAuBR,CAAA,CAAvBS,uBAAA;IACAC,CAAA,GAAwBV,CAAA,CAAxBW,wBAAA;IACAhB,CAAA,GAA2BK,CAAA,CAA3BY,2BAAA;IASMb,CAAA,GAAsBc,CAAA,CAAY;MACjCH,CAAA,IAEHI,UAAA,CAAW;QAAA,OAAMnB,CAAA,EAA4B,EAAK;MAAA,GAAEoB,CAAA,CAExD;IAAA,GAAG,CAACL,CAAA,EAA0Bf,CAAA;IAExBqB,CAAA,GAAsBH,CAAA,CAAY;MAClCH,CAAA,IAA0Bf,CAAA,EAA4B,EAC5D;IAAA,GAAG,CAACe,CAAA,EAA0Bf,CAAA;EAG9BsB,CAAA,CAAuB;IACrBC,GAAA,EAAKf,CAAA;IACLgB,iBAAA,EAAmBpB;EAAA,IAGrBqB,CAAA,CAAiB;IACfC,SAAA,EAAW;IACXH,GAAA,EAAKd,CAAA;IACLkB,QAAA,EAAUN;EAAA,IAIZO,CAAA,CAAY;IACVC,IAAA,EAAM9B,CAAA;IACNwB,GAAA,EAAKf,CAAA;IACLsB,kBAAA,GAAoB;IACpBC,cAAA,GAAgB;IAChBJ,QAAA,EAAUT,CAAA,CAAY;MAChBH,CAAA,KAA0B,QAAAN,CAAA,QAA0B,IAA1BA,CAAA,CAA4BuB,OAAA,KAAWvB,CAAA,CAA2BuB,OAAA,CAAQC,KAAA,EAC1G;IAAA,GAAG,CAAClB,CAAA,EAA0BN,CAAA;EAAA,IAIhCmB,CAAA,CAAY;IACVC,IAAA,EAAM9B,CAAA;IACNmC,QAAA,EAAUN,CAAA,CAAYO,SAAA,CAAUC,KAAA;IAChCb,GAAA,EAAKf,CAAA;IACLmB,QAAA,EAAUN;EAAA,IAEZO,CAAA,CAAY;IACVC,IAAA,EAAM9B,CAAA;IACNwB,GAAA,EAAKd,CAAA;IACLqB,kBAAA,GAAoB;IACpBH,QAAA,EAAUT,CAAA,CAAY;MAAA,CAGpB,QAAAL,CAAA,QAAuB,IAAvBA,CAAA,CAAyBmB,OAAA,KAAWnB,CAAA,CAAwBmB,OAAA,CAAQC,KAAA,IAChElB,CAAA,IAA0Bf,CAAA,EAA4B,EAC3D;IAAA,GAAE,CAACa,CAAA,EAAyBE,CAAA,EAA0Bf,CAAA;EAAA,IAEzD4B,CAAA,CAAY;IACVC,IAAA,EAAM9B,CAAA;IACNwB,GAAA,EAAKd,CAAA;IACLyB,QAAA,EAAUN,CAAA,CAAYO,SAAA,CAAUC,KAAA;IAChCT,QAAA,EAAUT,CAAA,CAAY;MAAA,CAGpB,QAAAP,CAAA,QAAuB,IAAvBA,CAAA,CAAyBqB,OAAA,KAAWrB,CAAA,CAAwBqB,OAAA,CAAQC,KAAA,IAChElB,CAAA,IAA0Bf,CAAA,EAA4B,EAC3D;IAAA,GAAE,CAACW,CAAA,EAAyBI,CAAA,EAA0Bf,CAAA;EAAA,IAEzD4B,CAAA,CAAY;IACVC,IAAA,EAAM3B,CAAA;IACNqB,GAAA,EAAKd,CAAA;IACLkB,QAAA,EAAUT,CAAA,CAAY;MAAA,CACpB,QAAAV,CAAA,QAAmB,IAAnBA,CAAA,CAAqBwB,OAAA,KAAWxB,CAAA,CAAoBwB,OAAA,CAAQC,KAAA,IACxDlB,CAAA,IAA0Bf,CAAA,EAA4B,EAC3D;IAAA,GAAE,CAACQ,CAAA,EAAqBO,CAAA,EAA0Bf,CAAA;EAAA,IAErD4B,CAAA,CAAY;IACVC,IAAA,EAAM3B,CAAA;IACNqB,GAAA,EAAKf,CAAA;IACLmB,QAAA,EAAUN;EAAA,IAIZI,CAAA,CAAiB;IACfC,SAAA,EAAW;IACXH,GAAA,EAAKV,CAAA;IACLc,QAAA,EAAUN;EAAA,EAEd;AAAA;AAEa,IAAAA,CAAA,GAAiB,SAAAgB,CAC5BnB,CAAA,EACAU,CAAA,EACAH,CAAA,EACAH,CAAA,EACAF,CAAA;EAEA,IAAMpB,CAAA,GAAckB,CAAA,CAAKoB,KAAA;IACnBvC,CAAA,GAAoCwC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAAf,CAAA,GAAO;MAAAgB,KAAA,EAAOrB,CAAA,QAAgB,IAAY;IAAA;IAC9ElB,CAAA,GAAO,gBAAAwC,MAAA,CAAmBd,CAAA,EAAa;EAE7C,OACEvB,CAAA,CAACM,CAAA,EAAgB4B,MAAA,CAAAC,MAAA;IAEfG,WAAA,KAAe,QAAA3C,CAAA,YAAAA,CAAA,CAAa4C,OAAA;IAC5BC,cAAA,EAAgB;MAAED,OAAA,EAAS,SAAAA,CAAAvC,CAAA;QAAK,OAAIL,CAAA,CAAY4C,OAAA,CAAQvC,CAAA,EAAOL,CAAA,CAAY8C,EAAA,CAAG;MAAA;MAAEC,QAAA,EAAU;IAAA;EAAA,GAE1F;IAAAC,QAAA,EAAA3C,CAAA,QAAAkC,MAAA,CAAAC,MAAA;MAAKS,KAAA,EAAOlD;IAAA,GACV;MAAAiD,QAAA,EAAA1C,CAAA,CAACE,CAAA,EAAI+B,MAAA,CAAAC,MAAA;QAACU,SAAA,EAAW1C,CAAA,CAAK2C,UAAA,CAAWC,GAAA;QAAKC,GAAA,EAAK7C,CAAA,CAAK8C,IAAA,CAAKC,EAAA;QAAIC,cAAA,EAAgBtD;MAAA,GACvE;QAAA8C,QAAA,GAAA3C,CAAA,CAACI,CAAA,EAAM8B,MAAA,CAAAC,MAAA,KACDxC,CAAA,EAAW;UACfyD,YAAA,OAAc;UACdC,SAAA,EAAW;UACXC,UAAA,EAAY5C,CAAA;UACZ6C,IAAA,EAAMtC,CAAA,KAAQ,QAAAtB,CAAA,YAAAA,CAAA,CAAa4D,IAAA;UAC3Bb,QAAA,GAAW;QAAA,MAEX3B,CAAA,IACAf,CAAA,QAAAkC,MAAA,CAAAC,MAAA;UAAKM,EAAA,EAAI5C,CAAA;UAAS2D,SAAA,EAAWhD,CAAA,CAAuCiD;QAAA,GACjE;UAAAd,QAAA,EAAAhD,CAAA,CAAY+D;QAAA;MAAA;IAAA;EAAA,IAhBhBnC,CAAA,CAuBX;AAAA;AAAA,SAAAP,CAAA,IAAAgB,cAAA,EAAAjC,CAAA,IAAA4D,8BAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}