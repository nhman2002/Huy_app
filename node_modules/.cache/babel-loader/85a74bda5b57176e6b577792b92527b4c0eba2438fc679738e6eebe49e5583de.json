{"ast":null,"code":"import { useCallback as e, useMemo as t, useEffect as n, useRef as s } from \"react\";\nimport i from \"../useKeyEvent/index.js\";\nimport o from \"../useEventListener/index.js\";\nimport u from \"../usePrevious/index.js\";\nimport { getNextSelectableIndex as c, getPreviousSelectableIndex as r } from \"./useActiveDescendantListFocusHelpers.js\";\nimport l from \"../useListenFocusTriggers/index.js\";\nvar a;\n!function (e) {\n  e.UP = \"ArrowUp\", e.DOWN = \"ArrowDown\", e.RIGHT = \"ArrowRight\", e.LEFT = \"ArrowLeft\";\n}(a || (a = {}));\nfunction m(t) {\n  var n = t.itemsCount,\n    s = t.focusedElementRef,\n    o = t.visualFocusItemIndex,\n    u = t.setVisualFocusItemIndex,\n    l = t.isHorizontalList,\n    m = t.isItemSelectable,\n    I = t.listenerOptions,\n    d = t.triggeredByKeyboard,\n    f = l ? a.RIGHT : a.DOWN,\n    v = l ? a.LEFT : a.UP,\n    x = e(function (e) {\n      var t;\n      document.activeElement === s.current && (!d.current && (d.current = !0, o > -1) || (e === f ? t = c({\n        isItemSelectable: m,\n        visualFocusItemIndex: o,\n        itemsCount: n\n      }) : e === v && (t = r({\n        isItemSelectable: m,\n        visualFocusItemIndex: o,\n        itemsCount: n\n      })), t > -1 && t !== o && u(t)));\n    }, [s, d, f, v, o, u, m, n]),\n    F = e(function () {\n      x(v);\n    }, [v, x]),\n    b = e(function () {\n      x(f);\n    }, [f, x]);\n  i(Object.assign({\n    keys: [f],\n    callback: b\n  }, I)), i(Object.assign({\n    keys: [v],\n    callback: F\n  }, I));\n}\nfunction I(n) {\n  var s = n.visualFocusItemIndex,\n    o = n.focusedElementRef,\n    u = n.itemsCount,\n    c = n.setVisualFocusItemIndex,\n    r = n.onItemClick,\n    l = n.isItemSelectable,\n    a = n.listenerOptions,\n    m = void 0 === a ? void 0 : a,\n    I = n.isIgnoreSpaceAsItemSelection,\n    d = void 0 !== I && I,\n    f = t(function () {\n      return d ? [\"Enter\"] : [\"Enter\", \" \"];\n    }, [d]),\n    v = e(function (e, t) {\n      r && t >= 0 && u > t && l(t) && (s !== t && c(t), r(e, t));\n    }, [u, r, l, s, c]),\n    x = e(function (e) {\n      o.current.contains(document.activeElement) && v(e, s);\n    }, [v, o, s]);\n  i(Object.assign({\n    keys: f,\n    callback: x\n  }, m));\n}\nfunction d(t) {\n  var s = t.focusedElementRef,\n    i = t.visualFocusItemIndex,\n    c = t.setVisualFocusItemIndex,\n    r = u(s),\n    l = e(function () {\n      -1 !== i && c(-1);\n    }, [c, i]);\n  n(function () {\n    null === (null == s ? void 0 : s.current) && null !== (null == r ? void 0 : r.current) && l();\n  }, [s.current, r, l]), o({\n    eventName: \"blur\",\n    ref: s,\n    callback: l\n  });\n}\nfunction f(t) {\n  var n = t.focusedElementRef,\n    i = t.isItemSelectable,\n    o = t.visualFocusItemIndex,\n    u = t.setVisualFocusItemIndex,\n    r = t.itemsCount,\n    a = t.defaultVisualFocusItemIndex,\n    m = void 0 === a ? -1 : a,\n    I = s(!1),\n    d = e(function () {\n      var e;\n      (I.current = !0, o !== m) && (e = i(m) ? m : c({\n        isItemSelectable: i,\n        itemsCount: r,\n        visualFocusItemIndex: m\n      }), u(e));\n    }, [m, i, r, u, I, o]),\n    f = e(function () {\n      I.current = !1;\n    }, [I]);\n  return l({\n    ref: n,\n    onFocusByKeyboard: d,\n    onFocusByMouse: f\n  }), {\n    triggeredByKeyboard: I\n  };\n}\nfunction v(e) {\n  var t = e.visualFocusItemIndex,\n    s = e.itemsIds,\n    i = e.isItemSelectable,\n    o = e.setVisualFocusItemIndex,\n    r = u(s);\n  n(function () {\n    var e;\n    void 0 !== r && r !== s && void 0 !== r && -1 !== t ? e = s.indexOf(r[t]) : e = t;\n    if (e !== t) if (i(e)) o(e);else {\n      var n = c({\n        isItemSelectable: i,\n        visualFocusItemIndex: e,\n        itemsCount: s.length\n      });\n      o(n);\n    }\n  }, [t, s, i, o, r]);\n}\nexport { d as useCleanVisualFocusOnBlur, v as useKeepFocusOnItemWhenListChanged, f as useSetDefaultItemOnFocusEvent, m as useSupportArrowsKeyboardNavigation, I as useSupportPressItemKeyboardNavigation };","map":{"version":3,"names":["a","e","UP","DOWN","RIGHT","LEFT","m","t","n","itemsCount","s","focusedElementRef","o","visualFocusItemIndex","u","setVisualFocusItemIndex","l","isHorizontalList","isItemSelectable","I","listenerOptions","d","triggeredByKeyboard","f","v","x","document","activeElement","current","c","r","F","b","i","Object","assign","keys","callback","onItemClick","isIgnoreSpaceAsItemSelection","contains","eventName","ref","defaultVisualFocusItemIndex","onFocusByKeyboard","onFocusByMouse","itemsIds","indexOf","length","useCleanVisualFocusOnBlur","useKeepFocusOnItemWhenListChanged","useSetDefaultItemOnFocusEvent","useSupportArrowsKeyboardNavigation","useSupportPressItemKeyboardNavigation"],"sources":["/Users/huynhmannguyen/Documents/GitHub/Huy_app/node_modules/monday-ui-react-core/src/hooks/useActiveDescendantListFocus/useActiveDescendantListFocusHooks.ts"],"sourcesContent":["import React, { MutableRefObject, useCallback, useEffect, useMemo, useRef } from \"react\";\nimport useKeyEvent, { UseKeyEventArgs } from \"../useKeyEvent\";\nimport useEventListener from \"../useEventListener\";\nimport usePrevious from \"../usePrevious\";\nimport { getNextSelectableIndex, getPreviousSelectableIndex } from \"./useActiveDescendantListFocusHelpers\";\nimport useListenFocusTriggers from \"../useListenFocusTriggers\";\n\nenum ArrowDirection {\n  UP = \"ArrowUp\",\n  DOWN = \"ArrowDown\",\n  RIGHT = \"ArrowRight\",\n  LEFT = \"ArrowLeft\"\n}\n\nconst ENTER_KEY = \"Enter\";\nconst SPACE_KEY = \" \";\n\nexport function useSupportArrowsKeyboardNavigation({\n  itemsCount,\n  focusedElementRef,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex,\n  isHorizontalList,\n  isItemSelectable,\n  listenerOptions,\n  triggeredByKeyboard\n}: {\n  itemsCount: number;\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  isHorizontalList: boolean;\n  isItemSelectable: (index: number) => boolean;\n  triggeredByKeyboard: MutableRefObject<boolean>;\n  listenerOptions: Omit<UseKeyEventArgs, \"keys\" | \"callback\">;\n}) {\n  const nextArrow = isHorizontalList ? ArrowDirection.RIGHT : ArrowDirection.DOWN;\n  const backArrow = isHorizontalList ? ArrowDirection.LEFT : ArrowDirection.UP;\n\n  const onArrowKeyEvent = useCallback(\n    (direction: ArrowDirection) => {\n      // we desire to change the visual focus item only if the user pressed on the keyboard arrows keys while\n      // the focusedElementRef is naturally focus\n      if (document.activeElement !== focusedElementRef.current) {\n        return;\n      }\n\n      // If the focusedElementRef is naturally focus but this is the first keyboard interaction of the user, we will mark future user interactions as trigger by keyboard (until the next mouse interaction)\n      // that from now on the interactions are trigger by keyboard (until the next mouse interaction)\n      if (!triggeredByKeyboard.current) {\n        triggeredByKeyboard.current = true;\n\n        // If the focusedElementRef is naturally focus but this is the first keyboard interaction of the user, we want only to display the item\n        // which right now visually focus without changing it.\n        if (visualFocusItemIndex > -1) {\n          return;\n        }\n      }\n\n      let newIndex;\n\n      // We will change the visual focused item index according to the direction of the pressed arrow\n      if (direction === nextArrow) {\n        newIndex = getNextSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount });\n      } else if (direction === backArrow) {\n        newIndex = getPreviousSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount });\n      }\n\n      if (newIndex > -1 && newIndex !== visualFocusItemIndex) setVisualFocusItemIndex(newIndex);\n    },\n    [\n      focusedElementRef,\n      triggeredByKeyboard,\n      nextArrow,\n      backArrow,\n      visualFocusItemIndex,\n      setVisualFocusItemIndex,\n      isItemSelectable,\n      itemsCount\n    ]\n  );\n  const onArrowBack = useCallback(() => {\n    onArrowKeyEvent(backArrow);\n  }, [backArrow, onArrowKeyEvent]);\n\n  const onArrowNext = useCallback(() => {\n    onArrowKeyEvent(nextArrow);\n  }, [nextArrow, onArrowKeyEvent]);\n\n  useKeyEvent({\n    keys: [nextArrow],\n    callback: onArrowNext,\n    ...listenerOptions\n  });\n\n  useKeyEvent({\n    keys: [backArrow],\n    callback: onArrowBack,\n    ...listenerOptions\n  });\n}\n\nexport function useSupportPressItemKeyboardNavigation({\n  visualFocusItemIndex,\n  focusedElementRef,\n  itemsCount,\n  setVisualFocusItemIndex,\n  onItemClick,\n  isItemSelectable,\n  listenerOptions = undefined,\n  isIgnoreSpaceAsItemSelection = false\n}: {\n  visualFocusItemIndex: number;\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  itemsCount: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  onItemClick: (event: React.MouseEvent | React.KeyboardEvent, index: number) => void;\n  isItemSelectable: (index: number) => boolean;\n  listenerOptions: Omit<UseKeyEventArgs, \"keys\" | \"callback\">;\n  isIgnoreSpaceAsItemSelection: boolean;\n}) {\n  const pressKeys = useMemo(\n    () => (isIgnoreSpaceAsItemSelection ? [ENTER_KEY] : [ENTER_KEY, SPACE_KEY]),\n    [isIgnoreSpaceAsItemSelection]\n  );\n\n  const baseOnClickCallback = useCallback(\n    (event: React.KeyboardEvent, itemIndex: number) => {\n      const hasValidIndex = itemIndex >= 0 && itemIndex < itemsCount;\n      if (!onItemClick || !hasValidIndex || !isItemSelectable(itemIndex)) return;\n      if (visualFocusItemIndex !== itemIndex) setVisualFocusItemIndex(itemIndex);\n      onItemClick(event, itemIndex);\n    },\n    [itemsCount, onItemClick, isItemSelectable, visualFocusItemIndex, setVisualFocusItemIndex]\n  );\n\n  const keyboardOnSelectCallback = useCallback(\n    (event: React.KeyboardEvent) => {\n      // we desire to change the trigger the active item on click callback only if the user pressed on the keyboard arrows keys while\n      // the focusedElementRef is naturally focus\n      if (focusedElementRef.current.contains(document.activeElement)) {\n        baseOnClickCallback(event, visualFocusItemIndex);\n      }\n    },\n    [baseOnClickCallback, focusedElementRef, visualFocusItemIndex]\n  );\n\n  useKeyEvent({\n    keys: pressKeys,\n    callback: keyboardOnSelectCallback,\n    ...listenerOptions\n  });\n}\n\nexport function useCleanVisualFocusOnBlur({\n  focusedElementRef,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex\n}: {\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n}) {\n  const previousFocusedElementRef = usePrevious(focusedElementRef);\n\n  const onBlurCallback = useCallback(() => {\n    if (visualFocusItemIndex !== -1) {\n      setVisualFocusItemIndex(-1);\n    }\n  }, [setVisualFocusItemIndex, visualFocusItemIndex]);\n\n  // if element unmount act like element got blur event\n  useEffect(() => {\n    // if element unmount\n    if (focusedElementRef?.current === null && previousFocusedElementRef?.current !== null) {\n      onBlurCallback();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [focusedElementRef.current, previousFocusedElementRef, onBlurCallback]);\n\n  useEventListener({\n    eventName: \"blur\",\n    ref: focusedElementRef,\n    callback: onBlurCallback\n  });\n}\n\nexport function useSetDefaultItemOnFocusEvent({\n  focusedElementRef,\n  isItemSelectable,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex,\n  itemsCount,\n  defaultVisualFocusItemIndex = -1\n}: {\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  isItemSelectable: (index: number) => boolean;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  itemsCount: number;\n  defaultVisualFocusItemIndex: number;\n}) {\n  const triggeredByKeyboard = useRef(false);\n\n  const onFocusByKeyboard = useCallback(() => {\n    triggeredByKeyboard.current = true;\n    if (visualFocusItemIndex !== defaultVisualFocusItemIndex) {\n      let newVisualFocusIndex;\n      if (isItemSelectable(defaultVisualFocusItemIndex)) {\n        newVisualFocusIndex = defaultVisualFocusItemIndex;\n      } else {\n        newVisualFocusIndex = getNextSelectableIndex({\n          isItemSelectable,\n          itemsCount,\n          visualFocusItemIndex: defaultVisualFocusItemIndex\n        });\n      }\n      setVisualFocusItemIndex(newVisualFocusIndex);\n    }\n  }, [\n    defaultVisualFocusItemIndex,\n    isItemSelectable,\n    itemsCount,\n    setVisualFocusItemIndex,\n    triggeredByKeyboard,\n    visualFocusItemIndex\n  ]);\n  const onFocusByMouse = useCallback(() => {\n    triggeredByKeyboard.current = false;\n  }, [triggeredByKeyboard]);\n  useListenFocusTriggers({ ref: focusedElementRef, onFocusByKeyboard, onFocusByMouse });\n\n  return { triggeredByKeyboard };\n}\n\nexport function useKeepFocusOnItemWhenListChanged({\n  visualFocusItemIndex,\n  itemsIds,\n  isItemSelectable,\n  setVisualFocusItemIndex\n}: {\n  visualFocusItemIndex: number;\n  itemsIds: string[];\n  isItemSelectable: (index: number) => boolean;\n  setVisualFocusItemIndex: (index: number) => void;\n}) {\n  const prevItemIds = usePrevious(itemsIds);\n\n  // When item list changed, keep the focus on the same item\n  useEffect(() => {\n    // When the list is changing the index of the focused item is point to a different item then before and\n    // this is why we want to search for the new index of the item and change the index to point to it.\n    let overrideIndexAfterListChanged;\n    const isListChanged = prevItemIds !== undefined && prevItemIds !== itemsIds;\n    if (isListChanged && prevItemIds !== undefined && visualFocusItemIndex !== -1) {\n      const focusedItemId = prevItemIds[visualFocusItemIndex];\n      overrideIndexAfterListChanged = itemsIds.indexOf(focusedItemId);\n    } else {\n      overrideIndexAfterListChanged = visualFocusItemIndex;\n    }\n\n    if (overrideIndexAfterListChanged !== visualFocusItemIndex) {\n      if (isItemSelectable(overrideIndexAfterListChanged)) {\n        setVisualFocusItemIndex(overrideIndexAfterListChanged);\n      } else {\n        const closestSelectableIndex = getNextSelectableIndex({\n          isItemSelectable,\n          visualFocusItemIndex: overrideIndexAfterListChanged,\n          itemsCount: itemsIds.length\n        });\n        setVisualFocusItemIndex(closestSelectableIndex);\n      }\n    }\n  }, [visualFocusItemIndex, itemsIds, isItemSelectable, setVisualFocusItemIndex, prevItemIds]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}