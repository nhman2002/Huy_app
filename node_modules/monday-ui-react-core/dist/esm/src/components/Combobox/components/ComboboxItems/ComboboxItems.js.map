{"version":3,"file":"ComboboxItems.js","sources":["../../../../../../../src/components/Combobox/components/ComboboxItems/ComboboxItems.tsx"],"sourcesContent":["import React, { CSSProperties, forwardRef, RefObject, useCallback, useMemo, useRef } from \"react\";\nimport cx from \"classnames\";\nimport { comboboxItemRenderer } from \"../../ComboboxHelpers/ComboboxHelpers\";\nimport VirtualizedList from \"../../../../components/VirtualizedList/VirtualizedList\";\nimport {\n  COMBOBOX_CATEGORY_ITEM,\n  COMBOBOX_OPTION_ITEM,\n  IComboboxCategoryMap,\n  IComboboxItem,\n  IComboboxOption,\n  IComboboxOptionEvents\n} from \"../ComboboxConstants\";\nimport styles from \"./ComboboxItems.module.scss\";\n\ninterface ComboboxItemsProps extends IComboboxOptionEvents {\n  className?: string;\n  optionClassName?: string;\n  categories?: IComboboxCategoryMap;\n  options?: IComboboxItem[];\n  optionRenderer?: (option: IComboboxOption) => JSX.Element;\n  activeItemIndex?: number;\n  visualFocusItemIndex?: number;\n  optionLineHeight?: number;\n  shouldScrollToSelectedItem?: boolean;\n  renderOnlyVisibleOptions?: boolean;\n  onActiveCategoryChanged?: (category: IComboboxItem) => void;\n  maxOptionsWithoutScroll?: number;\n  itemsMap?: Map<string, IComboboxItem>;\n  stickyCategories?: boolean;\n}\n\nexport const ComboboxItems: React.FC<ComboboxItemsProps> = forwardRef(\n  (\n    {\n      className,\n      optionClassName,\n      categories,\n      options,\n      optionRenderer,\n      activeItemIndex,\n      visualFocusItemIndex,\n      onOptionClick,\n      onOptionEnter,\n      onOptionLeave,\n      optionLineHeight,\n      shouldScrollToSelectedItem,\n      renderOnlyVisibleOptions,\n      onActiveCategoryChanged,\n      maxOptionsWithoutScroll,\n      itemsMap,\n      stickyCategories\n    },\n    ref: RefObject<HTMLDivElement>\n  ) => {\n    const activeCategoryId = useRef<string>();\n    const style = useMemo(() => {\n      if (maxOptionsWithoutScroll) {\n        // Adding 0.5 to show next option to indicate scroll is available\n        const maxCount = Math.min(options.length + Object.keys(categories ?? {}).length, maxOptionsWithoutScroll + 0.5);\n        return { height: optionLineHeight * maxCount };\n      }\n      return undefined;\n    }, [maxOptionsWithoutScroll, optionLineHeight, options, categories]);\n\n    const createItemElementRenderer = useCallback(\n      (item: IComboboxItem, index: number, style: CSSProperties) =>\n        comboboxItemRenderer({\n          stickyCategories,\n          item,\n          style,\n          optionEvents: {\n            onOptionClick,\n            onOptionEnter,\n            onOptionLeave\n          },\n          optionRenderData: {\n            className: optionClassName,\n            optionLineHeight,\n            optionRenderer,\n            visualFocusItemIndex,\n            scrollRef: renderOnlyVisibleOptions ? null : ref,\n            activeItemIndex,\n            shouldScrollToSelectedItem\n          },\n          isVirtualized: renderOnlyVisibleOptions\n        }),\n      [\n        onOptionClick,\n        onOptionEnter,\n        onOptionLeave,\n        optionClassName,\n        optionLineHeight,\n        optionRenderer,\n        visualFocusItemIndex,\n        renderOnlyVisibleOptions,\n        ref,\n        activeItemIndex,\n        shouldScrollToSelectedItem\n      ]\n    );\n\n    const onItemsRender = useCallback(\n      ({ firstItemId }: { firstItemId?: string }) => {\n        window.requestAnimationFrame(() => {\n          const itemData = itemsMap.get(firstItemId);\n          if (itemData && (itemData.type === COMBOBOX_CATEGORY_ITEM || itemData.type === COMBOBOX_OPTION_ITEM)) {\n            const newActiveCategoryId =\n              itemData.type === COMBOBOX_OPTION_ITEM && itemData.categoryId ? itemData.categoryId : itemData.id;\n\n            if (newActiveCategoryId !== activeCategoryId.current) {\n              activeCategoryId.current = newActiveCategoryId;\n              const categoryObject = itemsMap.get(activeCategoryId.current);\n              onActiveCategoryChanged(categoryObject);\n            }\n          }\n        });\n      },\n      [itemsMap, onActiveCategoryChanged]\n    );\n\n    let itemsElements;\n\n    // If we request to render only the items which visible in a given moment (optimization for very large lists)\n    if (renderOnlyVisibleOptions) {\n      itemsElements = (\n        <VirtualizedList\n          ref={ref}\n          className={cx(styles.optionsContainer, className)}\n          items={options}\n          itemRenderer={createItemElementRenderer}\n          role=\"treegrid\"\n          scrollableClassName={styles.scrollableContainer}\n          onItemsRendered={onItemsRender}\n          style={style}\n        />\n      );\n    } else {\n      itemsElements = (\n        <div\n          className={cx(styles.scrollableContainer, styles.optionsContainer, className)}\n          role=\"treegrid\"\n          style={style}\n          ref={ref}\n        >\n          {options.map((itemData, index) => createItemElementRenderer(itemData, index, undefined))}\n        </div>\n      );\n    }\n\n    return itemsElements;\n  }\n);\n"],"names":["ComboboxItems","forwardRef","_ref","ref","className","optionClassName","categories","options","optionRenderer","activeItemIndex","visualFocusItemIndex","onOptionClick","onOptionEnter","onOptionLeave","optionLineHeight","shouldScrollToSelectedItem","renderOnlyVisibleOptions","onActiveCategoryChanged","maxOptionsWithoutScroll","itemsMap","stickyCategories","activeCategoryId","useRef","style","useMemo","height","Math","min","length","Object","keys","createItemElementRenderer","useCallback","item","index","comboboxItemRenderer","optionEvents","optionRenderData","scrollRef","isVirtualized","onItemsRender","_ref2","firstItemId","window","requestAnimationFrame","itemData","get","type","COMBOBOX_CATEGORY_ITEM","COMBOBOX_OPTION_ITEM","newActiveCategoryId","categoryId","id","current","categoryObject","_jsx","VirtualizedList","cx","styles","optionsContainer","items","itemRenderer","role","scrollableClassName","scrollableContainer","onItemsRendered","assign","children","map","undefined"],"mappings":"maA+BO,IAAMA,EAA8CC,GACzD,SAAAC,EAoBEC,GACE,IAnBAC,EAASF,EAATE,UACAC,EAAeH,EAAfG,gBACAC,EAAUJ,EAAVI,WACAC,EAAOL,EAAPK,QACAC,EAAcN,EAAdM,eACAC,EAAeP,EAAfO,gBACAC,EAAoBR,EAApBQ,qBACAC,EAAaT,EAAbS,cACAC,EAAaV,EAAbU,cACAC,EAAaX,EAAbW,cACAC,EAAgBZ,EAAhBY,iBACAC,EAA0Bb,EAA1Ba,2BACAC,EAAwBd,EAAxBc,yBACAC,EAAuBf,EAAvBe,wBACAC,EAAuBhB,EAAvBgB,wBACAC,EAAQjB,EAARiB,SACAC,EAAgBlB,EAAhBkB,iBAIIC,EAAmBC,IACnBC,EAAQC,GAAQ,WACpB,GAAIN,EAGF,MAAO,CAAEO,OAAQX,EADAY,KAAKC,IAAIpB,EAAQqB,OAASC,OAAOC,KAAKxB,QAAAA,EAAc,CAAA,GAAIsB,OAAQV,EAA0B,IAI9G,GAAE,CAACA,EAAyBJ,EAAkBP,EAASD,IAElDyB,EAA4BC,GAChC,SAACC,EAAqBC,EAAeX,GAAoB,OACvDY,EAAqB,CACnBf,iBAAAA,EACAa,KAAAA,EACAV,MAAAA,EACAa,aAAc,CACZzB,cAAAA,EACAC,cAAAA,EACAC,cAAAA,GAEFwB,iBAAkB,CAChBjC,UAAWC,EACXS,iBAAAA,EACAN,eAAAA,EACAE,qBAAAA,EACA4B,UAAWtB,EAA2B,KAAOb,EAC7CM,gBAAAA,EACAM,2BAAAA,GAEFwB,cAAevB,GAEnB,GAAA,CACEL,EACAC,EACAC,EACAR,EACAS,EACAN,EACAE,EACAM,EACAb,EACAM,EACAM,IAIEyB,EAAgBR,GACpB,SAAAS,GAA8C,IAA3CC,EAAWD,EAAXC,YACDC,OAAOC,uBAAsB,WAC3B,IAAMC,EAAW1B,EAAS2B,IAAIJ,GAC9B,GAAIG,IAAaA,EAASE,OAASC,GAA0BH,EAASE,OAASE,GAAuB,CACpG,IAAMC,EACJL,EAASE,OAASE,GAAwBJ,EAASM,WAAaN,EAASM,WAAaN,EAASO,GAEjG,GAAIF,IAAwB7B,EAAiBgC,QAAS,CACpDhC,EAAiBgC,QAAUH,EAC3B,IAAMI,EAAiBnC,EAAS2B,IAAIzB,EAAiBgC,SACrDpC,EAAwBqC,EACzB,CACF,CACH,GACF,GACA,CAACnC,EAAUF,IAgCb,OA1BID,EAEAuC,EAACC,GACCrD,IAAKA,EACLC,UAAWqD,EAAGC,EAAOC,iBAAkBvD,GACvCwD,MAAOrD,EACPsD,aAAc9B,EACd+B,KAAK,WACLC,oBAAqBL,EAAOM,oBAC5BC,gBAAiBzB,EACjBjB,MAAOA,IAKTgC,EAAA,MAAA1B,OAAAqC,OAAA,CACE9D,UAAWqD,EAAGC,EAAOM,oBAAqBN,EAAOC,iBAAkBvD,GACnE0D,KAAK,WACLvC,MAAOA,EACPpB,IAAKA,GAEJ,CAAAgE,SAAA5D,EAAQ6D,KAAI,SAACvB,EAAUX,GAAK,OAAKH,EAA0Bc,EAAUX,OAAOmC,EAAU,MAM/F"}