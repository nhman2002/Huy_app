{"version":3,"file":"useActiveDescendantListFocus.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,UACR,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,SAAUJ,GACQ,iBAAZC,QACdA,QAAQ,gBAAkBD,EAAQG,QAAQ,UAE1CJ,EAAK,gBAAkBC,EAAQD,EAAY,OAR7C,CASGO,MAAOC,G,8KCHV,mCAAuC,iBAAEC,EAAgB,qBAAEC,EAAoB,WAAEC,IAC/E,KAAID,EAAuBC,EAAa,GAExC,IAAK,IAAIC,EAAS,EAAGA,GAAUD,EAAYC,IAAU,CACnD,MAAMC,GAAaH,EAAuBE,GAAUD,EACpD,GAAIF,EAAiBI,GACnB,OAAOA,IAIb,uCAA2C,iBACzCJ,EAAgB,qBAChBC,EAAoB,WACpBC,IAEA,IAAK,IAAIC,EAAS,EAAGA,GAAUD,EAAa,EAAGC,IAAU,CACvD,IAAIE,EAAYJ,EAAuBE,EAIvC,GAHIE,EAAY,IACdA,EAAYH,EAAaG,GAEvBL,EAAiBK,GACnB,OAAOA,K,+UC3Bb,gBACA,cACA,cACA,cACA,WACA,cAEA,IAAKC,GAAL,SAAKA,GACH,eACA,mBACA,qBACA,mBAJF,CAAKA,IAAAA,EAAc,KAOnB,MAAMC,EAAY,QAGlB,+CAAmD,WACjDL,EAAU,kBACVM,EAAiB,qBACjBP,EAAoB,wBACpBQ,EAAuB,iBACvBC,EAAgB,iBAChBV,EAAgB,gBAChBW,EAAe,oBACfC,IAWA,MAAMC,EAAYH,EAAmBJ,EAAeQ,MAAQR,EAAeS,KACrEC,EAAYN,EAAmBJ,EAAeW,KAAOX,EAAeY,GAEpEC,GAAkB,IAAAC,cACrBC,IAGC,GAAIC,SAASC,gBAAkBf,EAAkBgB,QAC/C,OAKF,IAAKZ,EAAoBY,UACvBZ,EAAoBY,SAAU,EAI1BvB,GAAwB,GAC1B,OAIJ,IAAIwB,EAGAJ,IAAcR,EAChBY,GAAW,IAAAC,wBAAuB,CAAE1B,iBAAAA,EAAkBC,qBAAAA,EAAsBC,WAAAA,IACnEmB,IAAcL,IACvBS,GAAW,IAAAE,4BAA2B,CAAE3B,iBAAAA,EAAkBC,qBAAAA,EAAsBC,WAAAA,KAG9EuB,GAAY,GAAKA,IAAaxB,GAAsBQ,EAAwBgB,KAElF,CACEjB,EACAI,EACAC,EACAG,EACAf,EACAQ,EACAT,EACAE,IAGE0B,GAAc,IAAAR,cAAY,KAC9BD,EAAgBH,KACf,CAACA,EAAWG,IAETU,GAAc,IAAAT,cAAY,KAC9BD,EAAgBN,KACf,CAACA,EAAWM,KAEf,aAAW,eACTW,KAAM,CAACjB,GACPkB,SAAUF,GACPlB,KAGL,aAAW,eACTmB,KAAM,CAACd,GACPe,SAAUH,GACPjB,KAIP,kDAAsD,qBACpDV,EAAoB,kBACpBO,EAAiB,WACjBN,EAAU,wBACVO,EAAuB,YACvBuB,EAAW,iBACXhC,EAAgB,gBAChBW,EAA2B,6BAC3BsB,GAA+B,IAW/B,MAAMC,GAAY,IAAAC,UAChB,IAAOF,EAA+B,CAAC1B,GAAa,CAACA,EA3GvC,MA4Gd,CAAC0B,IAGGG,GAAsB,IAAAhB,cAC1B,CAACiB,EAA4BC,KAEtBN,IADiBM,GAAa,GAAKA,EAAYpC,IACbF,EAAiBsC,KACpDrC,IAAyBqC,GAAW7B,EAAwB6B,GAChEN,EAAYK,EAAOC,MAErB,CAACpC,EAAY8B,EAAahC,EAAkBC,EAAsBQ,IAG9D8B,GAA2B,IAAAnB,cAC9BiB,IAGK7B,EAAkBgB,QAAQgB,SAASlB,SAASC,gBAC9Ca,EAAoBC,EAAOpC,KAG/B,CAACmC,EAAqB5B,EAAmBP,KAG3C,aAAW,eACT6B,KAAMI,EACNH,SAAUQ,GACP5B,KAIP,sCAA0C,kBACxCH,EAAiB,qBACjBP,EAAoB,wBACpBQ,IAMA,MAAMgC,GAA4B,aAAYjC,GAExCkC,GAAiB,IAAAtB,cAAY,MACH,IAA1BnB,GACFQ,GAAyB,KAE1B,CAACA,EAAyBR,KAG7B,IAAA0C,YAAU,KAE2B,QAA/BnC,MAAAA,OAAiB,EAAjBA,EAAmBgB,UAA2D,QAAvCiB,MAAAA,OAAyB,EAAzBA,EAA2BjB,UACpEkB,MAGD,CAAClC,EAAkBgB,QAASiB,EAA2BC,KAE1D,aAAiB,CACfE,UAAW,OACXC,IAAKrC,EACLuB,SAAUW,KAId,0CAA8C,kBAC5ClC,EAAiB,iBACjBR,EAAgB,qBAChBC,EAAoB,wBACpBQ,EAAuB,WACvBP,EAAU,4BACV4C,GAA8B,IAS9B,MAAMlC,GAAsB,IAAAmC,SAAO,GAE7BC,GAAoB,IAAA5B,cAAY,KAEpC,GADAR,EAAoBY,SAAU,EAC1BvB,IAAyB6C,EAA6B,CACxD,IAAIG,EAEFA,EADEjD,EAAiB8C,GACGA,GAEA,IAAApB,wBAAuB,CAC3C1B,iBAAAA,EACAE,WAAAA,EACAD,qBAAsB6C,IAG1BrC,EAAwBwC,MAEzB,CACDH,EACA9C,EACAE,EACAO,EACAG,EACAX,IAEIiD,GAAiB,IAAA9B,cAAY,KACjCR,EAAoBY,SAAU,IAC7B,CAACZ,IAGJ,OAFA,aAAuB,CAAEiC,IAAKrC,EAAmBwC,kBAAAA,EAAmBE,eAAAA,IAE7D,CAAEtC,oBAAAA,IAGX,8CAAkD,qBAChDX,EAAoB,SACpBkD,EAAQ,iBACRnD,EAAgB,wBAChBS,IAOA,MAAM2C,GAAc,aAAYD,IAGhC,IAAAR,YAAU,KAGR,IAAIU,EAEJ,QADsCC,IAAhBF,GAA6BA,IAAgBD,QAC9BG,IAAhBF,IAAuD,IAA1BnD,EAA6B,CAC7E,MAAMsD,EAAgBH,EAAYnD,GAClCoD,EAAgCF,EAASK,QAAQD,QAEjDF,EAAgCpD,EAGlC,GAAIoD,IAAkCpD,EACpC,GAAID,EAAiBqD,GACnB5C,EAAwB4C,OACnB,CACL,MAAMI,GAAyB,IAAA/B,wBAAuB,CACpD1B,iBAAAA,EACAC,qBAAsBoD,EACtBnD,WAAYiD,EAASO,SAEvBjD,EAAwBgD,MAG3B,CAACxD,EAAsBkD,EAAUnD,EAAkBS,EAAyB2C,M,iECjRjF,gBAGA,oBAAyC,UACvCR,EAAS,SACTb,EAAQ,IACRc,EAAG,QACHc,GAAU,KAOV,IAAAhB,YAAU,KACR,MAAMiB,EAAaf,GAAOA,EAAIrB,QAC9B,IAAKoC,EAAY,OACjB,MAAMjD,EAAkB,CAAEgD,QAAAA,GAI1B,OAFAC,EAAWC,iBAAiBjB,EAAWb,EAAUpB,GAE1C,KACLiD,EAAWE,oBAAoBlB,EAAWb,EAAUpB,MAErD,CAACiC,EAAWC,EAAKd,EAAU4B,M,2JCxBhC,gBACA,cAKA,IAAKI,GAAL,SAAKA,GACH,eACA,iBACA,iBACA,mBACA,+BALF,CAAKA,IAAAA,EAAQ,KAoCb,SAAwBC,GAAY,KAClClC,EAAO,GAAE,SACTC,EAAQ,SACRkC,EAAQ,mBACRC,EAAkB,IAClBrB,EAAG,uBACHsB,GAAyB,EAAK,QAC9BR,GAAU,EAAK,eACfS,GAAiB,EAAK,gBACtBC,GAAkB,EAAK,aACvBC,EAAe,YAEf,MAAMC,GAAc,IAAAxB,QAAOzB,SAASkD,MAC9BC,GAAe,IAAArD,cAClBiB,IACC,MAAM,IAAEqC,GAAQrC,EACXP,EAAK6C,SAASD,KAGfT,IA/CmB,EAAC5B,EAAsB4B,IAC9CA,IAAaF,EAASa,aACjBvC,EAAMwC,SAAWxC,EAAMyC,QAGzBzC,EAAM4B,GA0CQc,CAAqB1C,EAAO4B,IAGzCC,IA3C0B,CAAC7B,IAC3B2C,OAAOC,OAAOjB,EAAYkB,WAAWC,MAAMC,IACjD,GAnBiB,kBAmBbA,EACF,QAAS/C,EAAM+C,MAwCYC,CAA4BhD,KAInD+B,GACF/B,EAAM+B,iBAGJC,GACFhC,EAAMgC,kBAGRtC,EAASM,OAEX,CAACP,EAAMmC,EAAUC,EAAoBE,EAAgBC,EAAiBtC,IAGxE,IAAIuD,EAGFA,EADEzC,IAEOsB,EACK,KAEAI,IAGhB,aAAiB,CACf3B,UAAW0B,EACXvC,SAAU0C,EACV5B,IAAKyC,EACL3B,QAAAA,IArDJ,YAyDAK,EAAYkB,UAAYnB,G,2JCnGxB,oBACA,UAEA,oBAA+C,IAC7ClB,EAAG,kBACHG,EAAiB,eACjBE,IAMA,MAAMqC,GAAqB,IAAAxC,SAAO,GAE5ByC,GAAc,IAAApE,cAAY,KAC9BmE,EAAmB/D,SAAU,IAC5B,CAAC+D,IAEEE,GAAU,IAAArE,cACbsE,IAEKH,EAAmB/D,QACrB0B,MAAAA,GAAAA,EAAiBwC,GAEjB1C,MAAAA,GAAAA,EAAoB0C,KAGxB,CAAC1C,EAAmBE,IAEhByC,GAAY,IAAAvE,cAAY,KAC5BmE,EAAmB/D,SAAU,IAC5B,CAAC+D,KAEJ,aAAiB,CACf3C,UAAW,YACXC,IAAAA,EACAd,SAAUyD,KAGZ,aAAiB,CACf5C,UAAW,QACXC,IAAAA,EACAd,SAAU0D,KAGZ,aAAiB,CACf7C,UAAW,UACXC,IAAAA,EACAd,SAAU4D,M,iEChDd,gBAEA,mBAA0CC,GACxC,MAAM/C,GAAM,IAAAE,aAAOO,GAInB,OAHA,IAAAuC,kBAAgB,KACdhD,EAAIrB,QAAUoE,KAET/C,EAAIrB,U,SCPb9B,EAAOD,QAAUM,ICCb+F,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB1C,IAAjB2C,EACH,OAAOA,EAAaxG,QAGrB,IAAIC,EAASoG,EAAyBE,GAAY,CAGjDvG,QAAS,IAOV,OAHAyG,EAAoBF,GAAUG,KAAKzG,EAAOD,QAASC,EAAQA,EAAOD,QAASsG,GAGpErG,EAAOD,QCpBfsG,EAAoBK,EAAK3G,IACH,oBAAX4G,QAA0BA,OAAOC,aAC1CtB,OAAOuB,eAAe9G,EAAS4G,OAAOC,YAAa,CAAEV,MAAO,WAE7DZ,OAAOuB,eAAe9G,EAAS,aAAc,CAAEmG,OAAO,K,gBCLvD,S,+DCAA,gBACA,WAQA,IAAKY,EASL,SAASC,GAA6B,kBACpCjG,EAAiB,SACjB2C,EAAQ,iBACRnD,EAAgB,YAChBgC,EAAW,6BACX0E,GAA+B,EAAK,mBACpCC,EAAqBH,EAAKI,MAAK,iBAC/BlG,GAAmB,EAAK,6BACxBuB,GAA+B,EAAK,0BACpC4E,GAA4B,EAAK,uBACjC1C,GAAyB,IAazB,MAAMrB,EAA8B4D,EAA+B,GAAK,EAClExG,EAAaiD,EAASO,QACrBzD,EAAsBQ,IAA2B,IAAAqG,WAAkB,GACpEC,EAAoB5D,EAASlD,GAE7BU,GAAkB,IAAAwB,UAAQ,IAC1B0E,EACK1C,EAAyB,CAAEA,uBAAAA,QAA2Bb,EAGxD,CACLT,IAAKrC,EACL4D,gBAAgB,EAChBC,iBAAiB,IAElB,CAACwC,EAA2BrG,EAAmB2D,KAE5C,oBAAEvD,IAAwB,IAAAoG,+BAA8B,CAC5DxG,kBAAAA,EACAR,iBAAAA,EACAC,qBAAAA,EACAQ,wBAAAA,EACAP,WAAAA,EACA4C,4BAAAA,IAGImE,GAAuB,IAAA7F,cAC3B,CAAC2F,EAA2BG,KAC1BtG,EAAoBY,QAAU0F,EAC9B,MAAM5E,EAAYa,EAASK,QAAQuD,GAC/BzE,GAAa,GAAKA,IAAcrC,GAClCQ,EAAwB6B,KAG5B,CAACa,EAAUvC,EAAqBX,KAGlC,IAAAkH,oCAAmC,CACjCjH,WAAAA,EACAM,kBAAAA,EACAP,qBAAAA,EACAQ,wBAAAA,EACAG,oBAAAA,EACAF,iBAAAA,EACAV,iBAAAA,EACAW,gBAAAA,KAGF,IAAAyG,uCAAsC,CACpCnH,qBAAAA,EACAC,WAAAA,EACAM,kBAAAA,EACAC,wBAAAA,EACAuB,YAAAA,EACAhC,iBAAAA,EACAW,gBAAAA,EACAsB,6BAAAA,KAGF,IAAAoF,mCAAkC,CAChCpH,qBAAAA,EACAkD,SAAAA,EACAnD,iBAAAA,EACAS,wBAAAA,KAGF,IAAA6G,2BAA0B,CAAE9G,kBAAAA,EAAmBP,qBAAAA,EAAsBQ,wBAAAA,IAIrE,MAAM8G,GAA6C,IAAAnG,cAChDkB,GAAuBD,GAAkDL,EAAYK,EAAOC,IAC7F,CAACN,IAEH,MAAO,CACL/B,qBAAsBW,EAAoBY,QAAUvB,OAAuBqD,EAC3EyD,kBAAmBnG,EAAoBY,QAAUuF,OAAoBzD,EACrEkE,oBAAqB,CACnB,wBAAyB5G,EAAoBY,QAAUuF,OAAoBzD,EAC3EmE,KAAMd,GAIRe,oBAAqB1F,EACrB2F,0BAA2BJ,EAC3BN,qBAAAA,IArHJ,SAAKT,GACH,4BACA,sBACA,wBACA,gBACA,oBACA,cANF,CAAKA,IAAAA,EAAI,KAyHTC,EAA6BmB,MAAQpB,EAErC,UAAeC,G","sources":["webpack://monday-style/webpack/universalModuleDefinition","webpack://monday-style/./src/hooks/useActiveDescendantListFocus/useActiveDescendantListFocusHelpers.ts","webpack://monday-style/./src/hooks/useActiveDescendantListFocus/useActiveDescendantListFocusHooks.ts","webpack://monday-style/./src/hooks/useEventListener/index.ts","webpack://monday-style/./src/hooks/useKeyEvent/index.ts","webpack://monday-style/./src/hooks/useListenFocusTriggers/index.ts","webpack://monday-style/./src/hooks/usePrevious/index.ts","webpack://monday-style/external umd \"react\"","webpack://monday-style/webpack/bootstrap","webpack://monday-style/webpack/runtime/make namespace object","webpack://monday-style/./src/style-imports.ts","webpack://monday-style/./src/hooks/useActiveDescendantListFocus/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"monday-style\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"monday-style\"] = factory(root[\"react\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__8156__) => {\nreturn ","type ActiveDependentHelper = {\n  isItemSelectable: (index: number) => boolean;\n  visualFocusItemIndex: number;\n  itemsCount: number;\n};\n\nexport function getNextSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount }: ActiveDependentHelper) {\n  if (visualFocusItemIndex > itemsCount - 1) return;\n  // Go over all the next items until found one which is selectable\n  for (let offset = 1; offset <= itemsCount; offset++) {\n    const nextIndex = (visualFocusItemIndex + offset) % itemsCount;\n    if (isItemSelectable(nextIndex)) {\n      return nextIndex;\n    }\n  }\n}\nexport function getPreviousSelectableIndex({\n  isItemSelectable,\n  visualFocusItemIndex,\n  itemsCount\n}: ActiveDependentHelper) {\n  for (let offset = 1; offset <= itemsCount - 1; offset++) {\n    let prevIndex = visualFocusItemIndex - offset;\n    if (prevIndex < 0) {\n      prevIndex = itemsCount + prevIndex;\n    }\n    if (isItemSelectable(prevIndex)) {\n      return prevIndex;\n    }\n  }\n}\n","import React, { MutableRefObject, useCallback, useEffect, useMemo, useRef } from \"react\";\nimport useKeyEvent, { UseKeyEventArgs } from \"../useKeyEvent\";\nimport useEventListener from \"../useEventListener\";\nimport usePrevious from \"../usePrevious\";\nimport { getNextSelectableIndex, getPreviousSelectableIndex } from \"./useActiveDescendantListFocusHelpers\";\nimport useListenFocusTriggers from \"../useListenFocusTriggers\";\n\nenum ArrowDirection {\n  UP = \"ArrowUp\",\n  DOWN = \"ArrowDown\",\n  RIGHT = \"ArrowRight\",\n  LEFT = \"ArrowLeft\"\n}\n\nconst ENTER_KEY = \"Enter\";\nconst SPACE_KEY = \" \";\n\nexport function useSupportArrowsKeyboardNavigation({\n  itemsCount,\n  focusedElementRef,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex,\n  isHorizontalList,\n  isItemSelectable,\n  listenerOptions,\n  triggeredByKeyboard\n}: {\n  itemsCount: number;\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  isHorizontalList: boolean;\n  isItemSelectable: (index: number) => boolean;\n  triggeredByKeyboard: MutableRefObject<boolean>;\n  listenerOptions: Omit<UseKeyEventArgs, \"keys\" | \"callback\">;\n}) {\n  const nextArrow = isHorizontalList ? ArrowDirection.RIGHT : ArrowDirection.DOWN;\n  const backArrow = isHorizontalList ? ArrowDirection.LEFT : ArrowDirection.UP;\n\n  const onArrowKeyEvent = useCallback(\n    (direction: ArrowDirection) => {\n      // we desire to change the visual focus item only if the user pressed on the keyboard arrows keys while\n      // the focusedElementRef is naturally focus\n      if (document.activeElement !== focusedElementRef.current) {\n        return;\n      }\n\n      // If the focusedElementRef is naturally focus but this is the first keyboard interaction of the user, we will mark future user interactions as trigger by keyboard (until the next mouse interaction)\n      // that from now on the interactions are trigger by keyboard (until the next mouse interaction)\n      if (!triggeredByKeyboard.current) {\n        triggeredByKeyboard.current = true;\n\n        // If the focusedElementRef is naturally focus but this is the first keyboard interaction of the user, we want only to display the item\n        // which right now visually focus without changing it.\n        if (visualFocusItemIndex > -1) {\n          return;\n        }\n      }\n\n      let newIndex;\n\n      // We will change the visual focused item index according to the direction of the pressed arrow\n      if (direction === nextArrow) {\n        newIndex = getNextSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount });\n      } else if (direction === backArrow) {\n        newIndex = getPreviousSelectableIndex({ isItemSelectable, visualFocusItemIndex, itemsCount });\n      }\n\n      if (newIndex > -1 && newIndex !== visualFocusItemIndex) setVisualFocusItemIndex(newIndex);\n    },\n    [\n      focusedElementRef,\n      triggeredByKeyboard,\n      nextArrow,\n      backArrow,\n      visualFocusItemIndex,\n      setVisualFocusItemIndex,\n      isItemSelectable,\n      itemsCount\n    ]\n  );\n  const onArrowBack = useCallback(() => {\n    onArrowKeyEvent(backArrow);\n  }, [backArrow, onArrowKeyEvent]);\n\n  const onArrowNext = useCallback(() => {\n    onArrowKeyEvent(nextArrow);\n  }, [nextArrow, onArrowKeyEvent]);\n\n  useKeyEvent({\n    keys: [nextArrow],\n    callback: onArrowNext,\n    ...listenerOptions\n  });\n\n  useKeyEvent({\n    keys: [backArrow],\n    callback: onArrowBack,\n    ...listenerOptions\n  });\n}\n\nexport function useSupportPressItemKeyboardNavigation({\n  visualFocusItemIndex,\n  focusedElementRef,\n  itemsCount,\n  setVisualFocusItemIndex,\n  onItemClick,\n  isItemSelectable,\n  listenerOptions = undefined,\n  isIgnoreSpaceAsItemSelection = false\n}: {\n  visualFocusItemIndex: number;\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  itemsCount: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  onItemClick: (event: React.MouseEvent | React.KeyboardEvent, index: number) => void;\n  isItemSelectable: (index: number) => boolean;\n  listenerOptions: Omit<UseKeyEventArgs, \"keys\" | \"callback\">;\n  isIgnoreSpaceAsItemSelection: boolean;\n}) {\n  const pressKeys = useMemo(\n    () => (isIgnoreSpaceAsItemSelection ? [ENTER_KEY] : [ENTER_KEY, SPACE_KEY]),\n    [isIgnoreSpaceAsItemSelection]\n  );\n\n  const baseOnClickCallback = useCallback(\n    (event: React.KeyboardEvent, itemIndex: number) => {\n      const hasValidIndex = itemIndex >= 0 && itemIndex < itemsCount;\n      if (!onItemClick || !hasValidIndex || !isItemSelectable(itemIndex)) return;\n      if (visualFocusItemIndex !== itemIndex) setVisualFocusItemIndex(itemIndex);\n      onItemClick(event, itemIndex);\n    },\n    [itemsCount, onItemClick, isItemSelectable, visualFocusItemIndex, setVisualFocusItemIndex]\n  );\n\n  const keyboardOnSelectCallback = useCallback(\n    (event: React.KeyboardEvent) => {\n      // we desire to change the trigger the active item on click callback only if the user pressed on the keyboard arrows keys while\n      // the focusedElementRef is naturally focus\n      if (focusedElementRef.current.contains(document.activeElement)) {\n        baseOnClickCallback(event, visualFocusItemIndex);\n      }\n    },\n    [baseOnClickCallback, focusedElementRef, visualFocusItemIndex]\n  );\n\n  useKeyEvent({\n    keys: pressKeys,\n    callback: keyboardOnSelectCallback,\n    ...listenerOptions\n  });\n}\n\nexport function useCleanVisualFocusOnBlur({\n  focusedElementRef,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex\n}: {\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n}) {\n  const previousFocusedElementRef = usePrevious(focusedElementRef);\n\n  const onBlurCallback = useCallback(() => {\n    if (visualFocusItemIndex !== -1) {\n      setVisualFocusItemIndex(-1);\n    }\n  }, [setVisualFocusItemIndex, visualFocusItemIndex]);\n\n  // if element unmount act like element got blur event\n  useEffect(() => {\n    // if element unmount\n    if (focusedElementRef?.current === null && previousFocusedElementRef?.current !== null) {\n      onBlurCallback();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [focusedElementRef.current, previousFocusedElementRef, onBlurCallback]);\n\n  useEventListener({\n    eventName: \"blur\",\n    ref: focusedElementRef,\n    callback: onBlurCallback\n  });\n}\n\nexport function useSetDefaultItemOnFocusEvent({\n  focusedElementRef,\n  isItemSelectable,\n  visualFocusItemIndex,\n  setVisualFocusItemIndex,\n  itemsCount,\n  defaultVisualFocusItemIndex = -1\n}: {\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  isItemSelectable: (index: number) => boolean;\n  visualFocusItemIndex: number;\n  setVisualFocusItemIndex: (index: number) => void;\n  itemsCount: number;\n  defaultVisualFocusItemIndex: number;\n}) {\n  const triggeredByKeyboard = useRef(false);\n\n  const onFocusByKeyboard = useCallback(() => {\n    triggeredByKeyboard.current = true;\n    if (visualFocusItemIndex !== defaultVisualFocusItemIndex) {\n      let newVisualFocusIndex;\n      if (isItemSelectable(defaultVisualFocusItemIndex)) {\n        newVisualFocusIndex = defaultVisualFocusItemIndex;\n      } else {\n        newVisualFocusIndex = getNextSelectableIndex({\n          isItemSelectable,\n          itemsCount,\n          visualFocusItemIndex: defaultVisualFocusItemIndex\n        });\n      }\n      setVisualFocusItemIndex(newVisualFocusIndex);\n    }\n  }, [\n    defaultVisualFocusItemIndex,\n    isItemSelectable,\n    itemsCount,\n    setVisualFocusItemIndex,\n    triggeredByKeyboard,\n    visualFocusItemIndex\n  ]);\n  const onFocusByMouse = useCallback(() => {\n    triggeredByKeyboard.current = false;\n  }, [triggeredByKeyboard]);\n  useListenFocusTriggers({ ref: focusedElementRef, onFocusByKeyboard, onFocusByMouse });\n\n  return { triggeredByKeyboard };\n}\n\nexport function useKeepFocusOnItemWhenListChanged({\n  visualFocusItemIndex,\n  itemsIds,\n  isItemSelectable,\n  setVisualFocusItemIndex\n}: {\n  visualFocusItemIndex: number;\n  itemsIds: string[];\n  isItemSelectable: (index: number) => boolean;\n  setVisualFocusItemIndex: (index: number) => void;\n}) {\n  const prevItemIds = usePrevious(itemsIds);\n\n  // When item list changed, keep the focus on the same item\n  useEffect(() => {\n    // When the list is changing the index of the focused item is point to a different item then before and\n    // this is why we want to search for the new index of the item and change the index to point to it.\n    let overrideIndexAfterListChanged;\n    const isListChanged = prevItemIds !== undefined && prevItemIds !== itemsIds;\n    if (isListChanged && prevItemIds !== undefined && visualFocusItemIndex !== -1) {\n      const focusedItemId = prevItemIds[visualFocusItemIndex];\n      overrideIndexAfterListChanged = itemsIds.indexOf(focusedItemId);\n    } else {\n      overrideIndexAfterListChanged = visualFocusItemIndex;\n    }\n\n    if (overrideIndexAfterListChanged !== visualFocusItemIndex) {\n      if (isItemSelectable(overrideIndexAfterListChanged)) {\n        setVisualFocusItemIndex(overrideIndexAfterListChanged);\n      } else {\n        const closestSelectableIndex = getNextSelectableIndex({\n          isItemSelectable,\n          visualFocusItemIndex: overrideIndexAfterListChanged,\n          itemsCount: itemsIds.length\n        });\n        setVisualFocusItemIndex(closestSelectableIndex);\n      }\n    }\n  }, [visualFocusItemIndex, itemsIds, isItemSelectable, setVisualFocusItemIndex, prevItemIds]);\n}\n","import { RefObject, useEffect } from \"react\";\nimport { GenericEventCallback } from \"../../types/events\";\n\nexport default function useEventListener({\n  eventName,\n  callback,\n  ref,\n  capture = false\n}: {\n  eventName: keyof HTMLElementEventMap | string;\n  callback: GenericEventCallback;\n  ref: RefObject<HTMLElement | Document>;\n  capture?: boolean;\n}): void {\n  useEffect(() => {\n    const refElement = ref && ref.current;\n    if (!refElement) return;\n    const listenerOptions = { capture };\n\n    refElement.addEventListener(eventName, callback, listenerOptions);\n\n    return () => {\n      refElement.removeEventListener(eventName, callback, listenerOptions);\n    };\n  }, [eventName, ref, callback, capture]);\n}\n","import { RefObject, useCallback, useRef } from \"react\";\nimport useEventListener from \"../useEventListener\";\nimport { GenericEventCallback } from \"../../types/events\";\n\nconst CTRL_OR_META = \"ctrlOrMetaKey\";\n\nenum Modifier {\n  ALT = \"altKey\",\n  META = \"metaKey\",\n  CTRL = \"ctrlKey\",\n  SHIFT = \"shiftKey\",\n  CTRL_OR_META = \"ctrlOrMetaKey\"\n}\n\nconst checkModifierInEvent = (event: KeyboardEvent, modifier: Modifier) => {\n  if (modifier === Modifier.CTRL_OR_META) {\n    return event.ctrlKey || event.metaKey;\n  }\n\n  return event[modifier];\n};\nconst checkWithoutModifierInEvent = (event: KeyboardEvent) => {\n  return !Object.values(useKeyEvent.modifiers).some((m: Modifier) => {\n    if (m !== CTRL_OR_META) {\n      return !!event[m];\n    }\n  });\n};\n\nexport interface UseKeyEventArgs {\n  keys: KeyboardEvent[\"key\"][];\n  callback: GenericEventCallback;\n  modifier?: Modifier;\n  keyEventName?: string;\n  withoutAnyModifier?: boolean;\n  ref?: RefObject<HTMLElement | Document>;\n  ignoreDocumentFallback?: boolean;\n  capture?: boolean;\n  preventDefault?: boolean;\n  stopPropagation?: boolean;\n}\n\nexport default function useKeyEvent({\n  keys = [],\n  callback,\n  modifier,\n  withoutAnyModifier,\n  ref,\n  ignoreDocumentFallback = false,\n  capture = false,\n  preventDefault = false,\n  stopPropagation = false,\n  keyEventName = \"keydown\" // need keydown and not keyup to prevent scrolling with prevent default, for example during menu keyboard navigation\n}: UseKeyEventArgs) {\n  const documentRef = useRef(document.body);\n  const onKeyUpPress = useCallback(\n    (event: KeyboardEvent) => {\n      const { key } = event;\n      if (!keys.includes(key)) {\n        return;\n      }\n      if (modifier && !checkModifierInEvent(event, modifier)) {\n        return;\n      }\n      if (withoutAnyModifier && !checkWithoutModifierInEvent(event)) {\n        return;\n      }\n\n      if (preventDefault) {\n        event.preventDefault();\n      }\n\n      if (stopPropagation) {\n        event.stopPropagation();\n      }\n\n      callback(event);\n    },\n    [keys, modifier, withoutAnyModifier, preventDefault, stopPropagation, callback]\n  );\n\n  let listenerRef;\n\n  if (ref) {\n    listenerRef = ref;\n  } else if (ignoreDocumentFallback) {\n    listenerRef = null;\n  } else {\n    listenerRef = documentRef;\n  }\n\n  useEventListener({\n    eventName: keyEventName,\n    callback: onKeyUpPress,\n    ref: listenerRef,\n    capture\n  });\n}\n\nuseKeyEvent.modifiers = Modifier;\n","import useEventListener from \"../useEventListener\";\nimport { RefObject, useCallback, useRef } from \"react\";\n\nexport default function useListenFocusTriggers({\n  ref,\n  onFocusByKeyboard,\n  onFocusByMouse\n}: {\n  ref: RefObject<HTMLElement>;\n  onFocusByKeyboard?: (event: FocusEvent) => void;\n  onFocusByMouse?: (event: FocusEvent) => void;\n}) {\n  const isElementMouseDown = useRef(false);\n\n  const onMouseDown = useCallback(() => {\n    isElementMouseDown.current = true;\n  }, [isElementMouseDown]);\n\n  const onFocus = useCallback(\n    (e: FocusEvent) => {\n      // if focus triggered by mouse down, call onFocusByMouse\n      if (isElementMouseDown.current) {\n        onFocusByMouse?.(e);\n      } else {\n        onFocusByKeyboard?.(e);\n      }\n    },\n    [onFocusByKeyboard, onFocusByMouse]\n  );\n  const onMouseUp = useCallback(() => {\n    isElementMouseDown.current = false;\n  }, [isElementMouseDown]);\n\n  useEventListener({\n    eventName: \"mousedown\",\n    ref,\n    callback: onMouseDown\n  });\n\n  useEventListener({\n    eventName: \"focus\",\n    ref,\n    callback: onFocus\n  });\n\n  useEventListener({\n    eventName: \"mouseup\",\n    ref,\n    callback: onMouseUp\n  });\n}\n","import { useLayoutEffect, useRef } from \"react\";\n\nexport default function usePrevious<Type>(value: Type): Type {\n  const ref = useRef(undefined);\n  useLayoutEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__8156__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import \"monday-ui-style/dist/index.min.css\";\n","import React, { useMemo, useState, useCallback, MutableRefObject } from \"react\";\nimport {\n  useSupportArrowsKeyboardNavigation,\n  useSupportPressItemKeyboardNavigation,\n  useSetDefaultItemOnFocusEvent,\n  useKeepFocusOnItemWhenListChanged,\n  useCleanVisualFocusOnBlur\n} from \"./useActiveDescendantListFocusHooks\";\n\nenum Role {\n  APPLICATION = \"application\",\n  COMBOBOX = \"combobox\",\n  COMPOSITE = \"composite\",\n  GROUP = \"group\",\n  TEXTBOX = \"textbox\",\n  MENU = \"menu\"\n}\n\nfunction useActiveDescendantListFocus({\n  focusedElementRef, // the reference for the component that listens to keyboard\n  itemsIds,\n  isItemSelectable,\n  onItemClick,\n  defaultVisualFocusFirstIndex = false,\n  focusedElementRole = Role.GROUP,\n  isHorizontalList = false,\n  isIgnoreSpaceAsItemSelection = false,\n  useDocumentEventListeners = false,\n  ignoreDocumentFallback = false\n}: {\n  focusedElementRef: MutableRefObject<HTMLElement>;\n  itemsIds: string[];\n  isItemSelectable: (index: number) => boolean;\n  onItemClick: (event: React.KeyboardEvent | React.MouseEvent, index: number) => void;\n  defaultVisualFocusFirstIndex?: boolean;\n  focusedElementRole?: Role;\n  isHorizontalList?: boolean;\n  isIgnoreSpaceAsItemSelection?: boolean;\n  useDocumentEventListeners?: boolean;\n  ignoreDocumentFallback?: boolean;\n}) {\n  const defaultVisualFocusItemIndex = defaultVisualFocusFirstIndex ? 0 : -1;\n  const itemsCount = itemsIds.length;\n  const [visualFocusItemIndex, setVisualFocusItemIndex] = useState<number>(-1);\n  const visualFocusItemId = itemsIds[visualFocusItemIndex];\n\n  const listenerOptions = useMemo(() => {\n    if (useDocumentEventListeners) {\n      return ignoreDocumentFallback ? { ignoreDocumentFallback } : undefined;\n    }\n\n    return {\n      ref: focusedElementRef,\n      preventDefault: true,\n      stopPropagation: true\n    };\n  }, [useDocumentEventListeners, focusedElementRef, ignoreDocumentFallback]);\n\n  const { triggeredByKeyboard } = useSetDefaultItemOnFocusEvent({\n    focusedElementRef,\n    isItemSelectable,\n    visualFocusItemIndex,\n    setVisualFocusItemIndex,\n    itemsCount,\n    defaultVisualFocusItemIndex\n  });\n\n  const setVisualFocusItemId = useCallback(\n    (visualFocusItemId: string, isTriggeredByKeyboard: boolean) => {\n      triggeredByKeyboard.current = isTriggeredByKeyboard;\n      const itemIndex = itemsIds.indexOf(visualFocusItemId);\n      if (itemIndex > -1 && itemIndex !== visualFocusItemIndex) {\n        setVisualFocusItemIndex(itemIndex);\n      }\n    },\n    [itemsIds, triggeredByKeyboard, visualFocusItemIndex]\n  );\n\n  useSupportArrowsKeyboardNavigation({\n    itemsCount,\n    focusedElementRef,\n    visualFocusItemIndex,\n    setVisualFocusItemIndex,\n    triggeredByKeyboard,\n    isHorizontalList,\n    isItemSelectable,\n    listenerOptions\n  });\n\n  useSupportPressItemKeyboardNavigation({\n    visualFocusItemIndex,\n    itemsCount,\n    focusedElementRef,\n    setVisualFocusItemIndex,\n    onItemClick,\n    isItemSelectable,\n    listenerOptions,\n    isIgnoreSpaceAsItemSelection\n  });\n\n  useKeepFocusOnItemWhenListChanged({\n    visualFocusItemIndex,\n    itemsIds,\n    isItemSelectable,\n    setVisualFocusItemIndex\n  });\n\n  useCleanVisualFocusOnBlur({ focusedElementRef, visualFocusItemIndex, setVisualFocusItemIndex });\n\n  // this callback function is not needed anymore (the developer does not need to replace  the element's on click with this callback).\n  // we keep it for backward compatibility\n  const backwardCompatibilityCreateOnClickCallback = useCallback(\n    (itemIndex: number) => (event: React.KeyboardEvent | React.MouseEvent) => onItemClick(event, itemIndex),\n    [onItemClick]\n  );\n  return {\n    visualFocusItemIndex: triggeredByKeyboard.current ? visualFocusItemIndex : undefined,\n    visualFocusItemId: triggeredByKeyboard.current ? visualFocusItemId : undefined,\n    focusedElementProps: {\n      \"aria-activedescendant\": triggeredByKeyboard.current ? visualFocusItemId : undefined,\n      role: focusedElementRole\n    },\n    // this callback function is not needed anymore (the developer does not need to replace  the element's on click with this callback).\n    // we keep it for backward compatibility\n    onItemClickCallback: onItemClick,\n    createOnItemClickCallback: backwardCompatibilityCreateOnClickCallback,\n    setVisualFocusItemId\n  };\n}\n\nuseActiveDescendantListFocus.roles = Role;\n\nexport default useActiveDescendantListFocus;\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__8156__","isItemSelectable","visualFocusItemIndex","itemsCount","offset","nextIndex","prevIndex","ArrowDirection","ENTER_KEY","focusedElementRef","setVisualFocusItemIndex","isHorizontalList","listenerOptions","triggeredByKeyboard","nextArrow","RIGHT","DOWN","backArrow","LEFT","UP","onArrowKeyEvent","useCallback","direction","document","activeElement","current","newIndex","getNextSelectableIndex","getPreviousSelectableIndex","onArrowBack","onArrowNext","keys","callback","onItemClick","isIgnoreSpaceAsItemSelection","pressKeys","useMemo","baseOnClickCallback","event","itemIndex","keyboardOnSelectCallback","contains","previousFocusedElementRef","onBlurCallback","useEffect","eventName","ref","defaultVisualFocusItemIndex","useRef","onFocusByKeyboard","newVisualFocusIndex","onFocusByMouse","itemsIds","prevItemIds","overrideIndexAfterListChanged","undefined","focusedItemId","indexOf","closestSelectableIndex","length","capture","refElement","addEventListener","removeEventListener","Modifier","useKeyEvent","modifier","withoutAnyModifier","ignoreDocumentFallback","preventDefault","stopPropagation","keyEventName","documentRef","body","onKeyUpPress","key","includes","CTRL_OR_META","ctrlKey","metaKey","checkModifierInEvent","Object","values","modifiers","some","m","checkWithoutModifierInEvent","listenerRef","isElementMouseDown","onMouseDown","onFocus","e","onMouseUp","value","useLayoutEffect","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","r","Symbol","toStringTag","defineProperty","Role","useActiveDescendantListFocus","defaultVisualFocusFirstIndex","focusedElementRole","GROUP","useDocumentEventListeners","useState","visualFocusItemId","useSetDefaultItemOnFocusEvent","setVisualFocusItemId","isTriggeredByKeyboard","useSupportArrowsKeyboardNavigation","useSupportPressItemKeyboardNavigation","useKeepFocusOnItemWhenListChanged","useCleanVisualFocusOnBlur","backwardCompatibilityCreateOnClickCallback","focusedElementProps","role","onItemClickCallback","createOnItemClickCallback","roles"],"sourceRoot":""}